#!/usr/bin/env ruby

def change_answer_format(answer, alpha, excl)
	array_answer = []

  # creates an array of hashes of different possible sets of answers
	answer.each do |string|
		string_hash = {}
  	split_string = string.split(" ")
  	split_string.each do |element|
  		if excl.include?(element)
				element = element.gsub("!", "")
  			string_hash[element.to_sym] = false
			elsif alpha.include?(element)
  			string_hash[element.to_sym] = true
			end
  	end
  	array_answer.push(string_hash)
	end

	array_answer
end

def change_signs(string, alpha, excl)
  # changes answers from positive to negative or vice versa
  split_string = string.split(" ")
  split_string.map! do |element|
		if excl.include?(element)
			element = element.gsub("!", "")
		elsif alpha.include?(element)
			element = "!" + element
		end
		element
	end
	return split_string.join(" ")
end

def split_on_spaces(array)
	# Split based on spaces
 	array.map! do |element|
 		element.split(/ /)
 	end
end

def check_characters_valid(arrays)
	# creates two arrays of allowed values for characters i.e. A or !A
  alpha = ('A'..'Z').to_a
  excl = []
  excl = alpha.map do |element|
  	'!' + element
  end

  arrays.each do |array|
  	last_element = array.length - 1
  	array.each_with_index do |element, index|
  		element = element.gsub(/[()]/, '')
	  	if excl.include?(element) || alpha.include?(element)
	  		next
	  	elsif element == '+' || element == '|' || element == '^'
	  		next
	  	else
	  		raise ArgumentError, "Invalid input in question, #{element}"
	  	end
	  end
  end
end

def format_letters(arrays)
	# Turn letters into format for being called from hash A => facts[:A]
	# p arrays
  arrays.map! do |array|
  	array.map! do |element|
  		# p element
	  	element = element.gsub(/([A-Z])/, 'facts[:\1]')
	  	element = element.gsub(/\+/, '&&')
	  	# p element
	  end
	end
end

def eval_array(arrays)
	facts = {}
	('A'..'Z').each {|letter| facts[letter] = false}
	# Join arrays and evaluate
	# puts "array"
	# p arrays
  arrays.each do |array|
		string = array.join(" ")
	  begin
			eval string
		rescue SyntaxError => se
		  raise "Rescue from syntax error #{string}"
		rescue Exception => e 
			raise "Rescue exception #{string}"
		end
	end
end

def parse(arguments)
	raise ArgumentError, 'Should only be one argument' if arguments.length != 1
	file = File.open(arguments[0], "r")
  data = file.read
  file.close
  array = data.split("\n")

  # Removes comments from file
 	array.map! do |element|
 		if element.nil? || element.empty?
 			next
 		end
		this = element.split('#')
		this[0].gsub(/\s+/, ' ').strip
 	end
 	array.reject! { |c| c.nil? || c.empty? }
  
 	queries    = array.pop
 	statements = array.pop
 	list_questions    = []
 	list_answers   = []

	# creates two arrays of allowed values for characters i.e. A or !A
  alpha = ('A'..'Z').to_a
  excl = []
  excl = alpha.map do |element|
  	'!' + element
  end

 	# Split the two halves
 	array.each do |element|
 		elements = element.split('=>')
 		if (elements[0].strip.empty? || elements[1].strip.empty?)
  		raise ArgumentError, 'Question is empty, please format file correctly'
 		end
 		list_questions.push(elements[0].strip)
 		list_answers.push(elements[1].strip)
 		# if (elements[2] != nil)
 		# 	exit
 		# end
 	end

 	split_on_spaces(list_questions)
 	split_on_spaces(list_answers)

 	# if and only if scenario, doubles rule opposite sides
 	list_questions.map!.with_index do |array, index|
 		if array[-1] == '<'
 			array.pop
 			list_questions.push(list_answers[index].dup)
 			list_answers.push(array.dup)
 		end
 		array
 	end

 	check_characters_valid(list_questions)
 	check_characters_valid(list_answers)

 	test_ans = list_answers.map(&:clone)

 	format_letters(list_questions)
 	format_letters(test_ans)

	eval_array(list_questions)
	# eval_array(test_ans)

	list_questions.map! do |array|
		array.join(" ")
	end
	##FIXME add bracket check to list_answers

	# Runs different answer scenarios and returns an array of possible ones
	list_answers.map! do |answer|
		answer = answer.join(" ")
	 	answer.gsub!(/[+]/, '')
		array = answer.split(/[()]/)
		new_array = []
		while array.count > new_array.count
			new_array = []
			array.each do |element|
				if element.include?('|')
					splitted = element.split(/[|]/, 2).map(&:strip)
					new_array += splitted
					next
				elsif element.include?('^')
					splitted = element.split(/[\^]/, 2).map(&:strip)
					before_change = splitted[0].dup
					splitted[0] = splitted[0] + " " + change_signs(splitted[1], alpha, excl)
					splitted[1] = splitted[1] + " " + change_signs(before_change, alpha, excl)
					new_array += splitted
					next
				end
				new_array << element
			end
			array,new_array = new_array,array
		end
		array
	end

	# Changes list of questions and answers to format needed for logic, {Q: [{A}, {A}, {A}], Q: [{A}, {A}, {A}]}
	final_answer_format = {}
	list_answers.each_with_index do |answer, index|
		while final_answer_format[list_questions[index]]
			list_questions[index] += ' '
		end
		final_answer_format[list_questions[index]] = change_answer_format(answer, alpha, excl)
	end

	statements = statements.split("")
	statements.map!.with_index do |element, index|
		p element
		if index == 0 && element != '='
			raise "Statements line must begin with an equals sign"
		elsif index == 0
			next
		elsif !alpha.include?(element)
			raise "Statement can only include capital alphabetical characters"
		end
		element.to_sym
	end
	queries = queries.split("")
	queries.map!.with_index do |element, index|
		p element
		if index == 0 && element != '?'
			raise "Statements line must begin with an equals sign"
		elsif index == 0
			next
		elsif !alpha.include?(element)
			raise "Statement can only include capital alphabetical characters"
		end
		element.to_sym
	end
	statements.compact!
	queries.compact!
	# should you check for multiple statement or queries that are the same 
	logic_this(final_answer_format, queries, statements)

end

parse(ARGV)